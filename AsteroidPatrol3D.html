<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<title>AsteroidPatrol3D</title>
	<style>
		body {
			background-color: rgb(0, 0, 0);
			margin: 0;
			padding: 0;
			overflow: hidden;
		}
	</style>
</head>

<body>
	<div id="container"></div>

	<div id="help" style="position:fixed; left:40%; top:3%; color:grey;">
		Asteroid Patrol 3D
	</div>
	
	<div id="help1" style="position:fixed; right:1%; bottom:8%; font-family:arial; font-size:10px; color:grey;">
		Desktop: Press 'M': MouseLook / LMouseButton: Fire / 'SPACE': Thrusters
	</div>

	<div id="help2" style="position:fixed; right:1%; bottom:4%; font-family:arial; font-size:10px; color:grey;">
		Mobile: Swipe to rotate / OrangeButton: Fire / PurpleButton: Thrusters
	</div>

	<div id="debug1" style="position:fixed; left:5%; top:3%; color:grey;">
		Debug Info
	</div>

	<div id="debug2" style="position:fixed; left:5%; top:6%; color:grey;">
		Debug Info
	</div>

	<div id="debug3" style="position:fixed; left:5%; top:9%; color:grey;">
		Debug Info
	</div>

	<div id="debug4" style="position:fixed; left:5%; top:12%; color:grey;">
		Debug Info
	</div>

	<!-- <script src="js/three.min.js"></script> -->
	<script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r68/three.min.js"></script>
	<script src="js/threex.keyboardstate.js"></script>
	<script src="js/threex.FirstPersonControls.js"></script>
	<script src="js/virtualButtonJoystick.js"></script>
	<script src="js/threex.GameTimer.js"></script>
	<script src="js/threex.geometricglowmesh.js"></script>
	<script src="js/webaudioxGameSounds.js"></script>
	<script src="js/AsteroidPatrolVariables.js"></script>

	<script>
		initLevel();
		animate();


		function initLevel() {
			
			//if we are on a later level, first clean up all of the old asteroid objects
			if(level > 0){
				
				for (var i = 0; i < numberOfLargeAsteroids; i++) {	
					scene.remove( largeAsteroids[i] );
				}
				for (var i = 0; i < numberOfMediumAsteroids; i++) {	
					scene.remove( mediumAsteroids[i] );
				}
				for (var i = 0; i < numberOfSmallAsteroids; i++) {	
					scene.remove( smallAsteroids[i] );
				}

			}
			
			//for debug collisions
			//level = 4;
			level += 1;
			numberOfLargeAsteroids = Math.floor( level * 3 + 2 );
			numberOfMediumAsteroids = numberOfLargeAsteroids * 2;
			numberOfSmallAsteroids = numberOfMediumAsteroids * 2;
			smallAsteroidsRemaining = numberOfSmallAsteroids;
			
			debugText1.innerHTML = "smallAsteroids remaining: " + Math.floor(smallAsteroidsRemaining);
			numberOfLargeAsteroidsCreated = 0;
			//build large asteroids
			for (var i = 0; i < numberOfLargeAsteroids; i++) {

				largeAsteroidGeometry = new THREE.IcosahedronGeometry(largeAsteroidRadius, 2);
				for (var v = 0; v < lvLength; v++) {	
					deformVec.set(Math.random() * 7, Math.random() * 7, Math.random() * 7);
					largeAsteroidGeometry.vertices[v].add(deformVec);
				}

				largeAsteroids[i] = new THREE.Mesh(largeAsteroidGeometry, asteroidMaterial);
				largeAsteroids[i].scale.set( (Math.random() * 0.4 - 0.25) + 1, (Math.random() * 0.4 - 0.25) + 1, (Math.random() * 0.4 - 0.25) + 1 );
				
				largeAsteroids[i].geometry.computeFaceNormals();
				largeAsteroids[i].geometry.computeVertexNormals();
				largeAsteroids[i].geometry.verticesNeedUpdate = true;
				largeAsteroids[i].geometry.normalsNeedUpdate = true;
				largeAsteroids[i].geometry.center();
				largeAsteroids[i].geometry.computeBoundingSphere();
				
				//var wireframe = new THREE.WireframeHelper(largeAsteroids[i]);
				//scene.add(wireframe);
				scene.add(largeAsteroids[i]);

				largeAsteroids[i].alive = true;
				largeAsteroids[i].visible = true;
				largeAsteroids[i].hasCollided = false;
				largeAsteroids[i].rotationAxis = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
				largeAsteroids[i].rotationAxis.normalize();
				largeAsteroids[i].rotationAmount = Math.random() * 0.3 + 0.1;//large spins slowest
				largeAsteroids[i].direction = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
				largeAsteroids[i].direction.normalize();
				largeAsteroids[i].mass = 100;
				largeAsteroids[i].speed = Math.random() * 20 + 10;
				numberOfLargeAsteroidsCreated += 1
				placingLargeAsteroids = true;
				while (placingLargeAsteroids) {
					placingLargeAsteroids = false;
					largeAsteroids[i].position.set( Math.random() * 800 - 400, Math.random() * 800 - 400, Math.random() * 800 - 400 );
					for (var j = 0; j < numberOfLargeAsteroidsCreated; j++) {
						if(i!=j && largeAsteroids[i].position.distanceTo(largeAsteroids[j].position) < 150)
							placingLargeAsteroids = true;
					}
				}
				
			}
			
			//build medium asteroids
			for (var i = 0; i < numberOfMediumAsteroids; i++) {

				mediumAsteroidGeometry = new THREE.IcosahedronGeometry(mediumAsteroidRadius, 1);
				for (var v = 0; v < mvLength; v++) {	
					deformVec.set(Math.random() * 7, Math.random() * 7, Math.random() * 7);
					mediumAsteroidGeometry.vertices[v].add(deformVec);
				}

				mediumAsteroids[i] = new THREE.Mesh(mediumAsteroidGeometry, asteroidMaterial);
				mediumAsteroids[i].scale.set( (Math.random() * 0.5 - 0.25) + 1, (Math.random() * 0.5 - 0.25) + 1, (Math.random() * 0.5 - 0.25) + 1 );
				
				mediumAsteroids[i].geometry.computeFaceNormals();
				mediumAsteroids[i].geometry.computeVertexNormals();
				mediumAsteroids[i].geometry.verticesNeedUpdate = true;
				mediumAsteroids[i].geometry.normalsNeedUpdate = true;
				mediumAsteroids[i].geometry.center();
				mediumAsteroids[i].geometry.computeBoundingSphere();
				scene.add(mediumAsteroids[i]);

				mediumAsteroids[i].alive = false;//these come alive when big ones break apart
				mediumAsteroids[i].visible = false;//these stay hidden until big ones break apart
				mediumAsteroids[i].hasCollided = false;
				mediumAsteroids[i].rotationAxis = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
				mediumAsteroids[i].rotationAxis.normalize();
				mediumAsteroids[i].rotationAmount = Math.random() * 0.5 + 0.7;//medium spins faster
				//give it a random direction
				mediumAsteroids[i].direction = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
				//if i index is odd, copy the direction created one iteration earlier, and negate it,
				//so it travels opposite its neighbor during large parent asteroid's explosion and its own(and partner's) creation
				if(i%2 == 1)
					mediumAsteroids[i].direction.copy(mediumAsteroids[i-1].direction).negate();
				mediumAsteroids[i].direction.normalize();
				mediumAsteroids[i].mass = 70;
				mediumAsteroids[i].speed = Math.random() * 20 + 20;//medium is faster speed
				mediumAsteroids[i].position.set(500, 500, 500);//place outside arena for now
			
			}
			
			//build small asteroids
			for (var i = 0; i < numberOfSmallAsteroids; i++) {

				smallAsteroidGeometry = new THREE.IcosahedronGeometry(smallAsteroidRadius, 0);
				for (var v = 0; v < svLength; v++) {	
					deformVec.set(Math.random() * 7, Math.random() * 7, Math.random() * 7);
					smallAsteroidGeometry.vertices[v].add(deformVec);
				}

				smallAsteroids[i] = new THREE.Mesh(smallAsteroidGeometry, asteroidMaterial);
				smallAsteroids[i].scale.set( (Math.random() * 0.5 - 0.25) + 1, (Math.random() * 0.5 - 0.25) + 1, (Math.random() * 0.5 - 0.25) + 1 );
				
				smallAsteroids[i].geometry.computeFaceNormals();
				smallAsteroids[i].geometry.computeVertexNormals();
				smallAsteroids[i].geometry.verticesNeedUpdate = true;
				smallAsteroids[i].geometry.normalsNeedUpdate = true;
				smallAsteroids[i].geometry.center();
				smallAsteroids[i].geometry.computeBoundingSphere();
				scene.add(smallAsteroids[i]);

				smallAsteroids[i].alive = false;//these come alive when medium ones break apart
				smallAsteroids[i].visible = false;//these stay hidden until medium ones break apart
				smallAsteroids[i].rotationAxis = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
				smallAsteroids[i].rotationAxis.normalize();
				smallAsteroids[i].rotationAmount = Math.random() * 2 + 2;//small spins fastest
				smallAsteroids[i].direction = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
				//if i index is odd, copy the direction created one iteration earlier, and negate it,
				//so it travels opposite its neighbor during medium parent asteroid's explosion and its own(and partner's) creation
				if(i%2 == 1)
					smallAsteroids[i].direction.copy(smallAsteroids[i-1].direction).negate();
				smallAsteroids[i].direction.normalize();
				smallAsteroids[i].mass = 30;
				smallAsteroids[i].speed = Math.random() * 20 + 30;//small is faster speed
				smallAsteroids[i].position.set(500, 500, 500);//place outside arena for now
			
			}

			//build explosion pieces
			for (var i = 0; i < numberOfExplosionPieces; i++) {
				
				explosionPieces[i] = new THREE.Mesh(explosionPiecesGeometry, asteroidMaterial);
				explosionPieces[i].scale.set( (Math.random() * 2 - 1) + 2, (Math.random() * 2 - 1) + 2, (Math.random() * 2 - 1) + 2 );
				explosionPieces[i].direction = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
				explosionPieces[i].direction.normalize();
				explosionPieces[i].speed = Math.random() * 200 + 100;
				explosionPieces[i].position.set(500, 500, 500);//place outside arena for now
				explosionPieces[i].visible = false;
				scene.add(explosionPieces[i]);
				
			}
	
			placeShip();
			
			//put the camera right where the ship is
			//camera.position.copy(ship.position);
			
			//setup controls parameters
			//controls.movementSpeed = 100;
			box.position.set(0,0,-150);
			box.rotation.y = 0.6;

		} //end function initLevel()
		

		function animate() {
			
			//keep looping through animate()
			requestAnimationFrame(animate);
			//store how much time has passed since the last animation frame
			frameTime = clock.getDelta();

			if (keyboard.pressed("M")) {

				mouseControl = true;

				if (canPressM) {
					joystick.savedMousePosX = joystick.mousePosX;
					joystick.savedMousePosY = joystick.mousePosY;
					//joystick._onDown(joystick.mousePosX, joystick.mousePosY);
					joystick.mouseDeltaX = 0;
					joystick.mouseDeltaY = 0;
					canPressM = false;
				}

			} else canPressM = true;

			if (mouseControl)
				joystick._pressed = true;

			//check if joystick Stick is being moved
			if (joystick._pressed) {

				if (mouseControl) {
					controls.lon = joystick.oldLon - (joystick.mouseDeltaX / 2);
					controls.lat = joystick.oldLat + (joystick.mouseDeltaY / 3);
				} else {
					//joystick left and right will turn the camera in that direction
					controls.lon = joystick.oldLon + (joystick.deltaX() / 3); // - 90
					//joystick up and down will tilt the camera up and down
					controls.lat = joystick.oldLat - (joystick.deltaY() / 4); // 0 -
				}

			}
			//if firebutton is NOT pressed, reset it so we can fire again
			if (!joystick.button1Pressed) {
				canShoot = true;
			}
			//if firebutton IS pressed, check to see if we can shoot
			if (joystick.button1Pressed) {
				if (canShoot) {
					shootBullet();
					//turn off shooting so we don't rapid fire
					canShoot = false;
				}
			}
			//if thrust button is pressed, apply thrust force to ship in the same direction that the camera is facing
			if (joystick.button2Pressed || keyboard.pressed('space')) {
				//reset the thrustVector to unit length of 1 to avoid accumulation
				thrustVector.set(0, 0, -1);
				//rotate thrustVector by our camera's rotation quaternion
				thrustVector.applyQuaternion(camera.quaternion);
				//now thrustVector has the right direction, but it needs magnitude also...
				//20 is the 'strength' of the thruster; this is multiplied by framerate so it will run consistently on different systems
				thrustVector.multiplyScalar(20 * frameTime);
				//add this new thrust to the ship's ongoing velocity
				shipVelocity.add(thrustVector);
				//record the current speed of the ship, which equals the length of its velocity vector
				shipSpeed = shipVelocity.length();
				//now record just the direction and save it as a unit length vector (length of 1)
				normalizedShipDirection.copy(shipVelocity);
				//the following clamps this vector to a unit length of 1
				normalizedShipDirection.normalize();

			}
			else{ //no thrust is being applied, so slow the ship down gradually
				//Although no air drag friction exists in space, this makes handling the ship easier
				if (shipSpeed > 0.1) {
					//first set frictionVector equal to shipVelocity vector, then negate it and normalize it, 
					//in order to point in the opposing direction
					frictionVector.copy(shipVelocity).negate().normalize();
					//10 is the amount of friction to apply
					frictionVector.multiplyScalar(10 * frameTime);
					//add the friction back in to the ship's ongoing velocity
					shipVelocity.add(frictionVector);
					//record the current speed of the ship, which equals the length of its velocity vector
					shipSpeed = shipVelocity.length();
				}
				else shipSpeed = 0;
			}
			
			//loop through bulletArray, update bullet positions, update collisions
			for (var i = 0; i < MAX_BULLETS; i++) {
				
				//deactivate bullets if they leave arena
				if(bulletArray[i].alive){
					if( bulletArray[i].position.x > arenaHalfSize || bulletArray[i].position.x < -arenaHalfSize || 
					    bulletArray[i].position.y > arenaHalfSize || bulletArray[i].position.y < -arenaHalfSize || 
					    bulletArray[i].position.z > arenaHalfSize || bulletArray[i].position.z < -arenaHalfSize ) {
					
						bulletArray[i].alive = false;
						bulletArray[i].visible = false;
					}
				}
				//if bullet is alive, update it
				if (bulletArray[i].alive){
					//keep updating the bullet ray to equal the bulletSphere's position and direction vectors,
					//so this ray can be used for ray-boundingSphere collision detection.
					bulletRay.set(bulletArray[i].position, bulletArray[i].direction);
					//record the current bullet location
					oldBulletSpherePos.copy(bulletArray[i].position);
					//move bullet along bullet direction vector, at the rate of bulletSpeed times the framerate
					bulletArray[i].translateOnAxis(bulletArray[i].direction, bulletSpeed * frameTime);
					//now that we have moved it, record the new bullet location
					newBulletSpherePos.copy(bulletArray[i].position);
					
					//loop through smallAsteroids and check for collisions with our bullets
					for (var c = 0; c < numberOfSmallAsteroids; c++) {
						//only check active alive asteroids
						if(smallAsteroids[c].alive){
							//set values for 'dummy' testSphere so we can test if our bullet path has intersected the asteroid
							testSphere.radius = smallAsteroids[c].geometry.boundingSphere.radius;
							testSphere.center.copy(smallAsteroids[c].position);
							bulletRayCollisionPoint = bulletRay.intersectSphere(testSphere);
							
							//if bulletRayCollisionPoint !== null
							if (bulletRayCollisionPoint) {
								//compare the distance between collision point and bullet object, vs. where the
								//bullet is now and where the bullet will end up the next frame, and if the first 
								//length is less, we have a collision.Â  Else, the collision point is too far away still.
								if (bulletRayCollisionPoint.distanceToSquared(bulletArray[i].position) < 
									newBulletSpherePos.distanceToSquared(oldBulletSpherePos)){

									bulletArray[i].alive = false;
									bulletArray[i].visible = false;
									//place it right where the collision occurred
									//bulletArray[i].position.copy(bulletRayCollisionPoint);
									smallAsteroids[c].alive = false;
									smallAsteroids[c].visible = false;
									
									initExplosionPieces(smallAsteroids[c].position);
									
									smallAsteroidsRemaining -= 1;
									if(smallAsteroidsRemaining < 1)
										initLevel();
									
									debugText1.innerHTML = "smallAsteroids remaining: " + Math.floor(smallAsteroidsRemaining);
							
								}

							}//end if (bulletRayCollisionPoint) {
							
						}//end if(smallAsteroids[c].alive) {
						
					}//end for(var c = 0; c < numberOfSmallAsteroids; c++) {
					
					//loop through mediumAsteroids and check for collisions with our bullets
					for (var c = 0; c < numberOfMediumAsteroids; c++) {
						
						if(mediumAsteroids[c].alive){
							
							testSphere.radius = mediumAsteroids[c].geometry.boundingSphere.radius;
							testSphere.center.copy(mediumAsteroids[c].position);
							bulletRayCollisionPoint = bulletRay.intersectSphere(testSphere);
							
							if (bulletRayCollisionPoint) {
								
								if (bulletRayCollisionPoint.distanceToSquared(bulletArray[i].position) < 
									newBulletSpherePos.distanceToSquared(oldBulletSpherePos)){

									bulletArray[i].alive = false;
									bulletArray[i].visible = false;
									//place it right where the collision occurred
									//bulletArray[i].position.copy(bulletRayCollisionPoint);
									mediumAsteroids[c].alive = false;
									mediumAsteroids[c].visible = false;
									
									//spawn 2 new small asteroids
									//small asteroid #1
									smallAsteroids[c*2].alive = true;
									smallAsteroids[c*2].visible = true;
									smallAsteroids[c*2].position.copy(mediumAsteroids[c].position);
									//move the new neighbooring asteroids away so they don't spawn on top of each other
									smallAsteroids[c*2].translateOnAxis(smallAsteroids[c*2].direction, smallAsteroids[c*2].geometry.boundingSphere.radius);
									//small asteroid #2
									smallAsteroids[c*2+1].alive = true;
									smallAsteroids[c*2+1].visible = true;
									smallAsteroids[c*2+1].position.copy(mediumAsteroids[c].position);
									//move the new neighbooring asteroids away so they don't spawn on top of each other
									smallAsteroids[c*2+1].translateOnAxis(smallAsteroids[c*2+1].direction, smallAsteroids[c*2+1].geometry.boundingSphere.radius);
									
									initExplosionPieces(mediumAsteroids[c].position);
									
								}

							}//end if (bulletRayCollisionPoint) {
							
						}//end if(mediumAsteroids[c].alive) {
						
					}//end for(var c = 0; c < numberOfMediumAsteroids; c++) {
					
					//loop through largeAsteroids and check for collisions with our bullets
					for (var c = 0; c < numberOfLargeAsteroids; c++) {
						
						if(largeAsteroids[c].alive){
							
							testSphere.radius = largeAsteroids[c].geometry.boundingSphere.radius;
							testSphere.center.copy(largeAsteroids[c].position);
							bulletRayCollisionPoint = bulletRay.intersectSphere(testSphere);
							
							if (bulletRayCollisionPoint) {
								
								if (bulletRayCollisionPoint.distanceToSquared(bulletArray[i].position) < 
									newBulletSpherePos.distanceToSquared(oldBulletSpherePos)){

									bulletArray[i].alive = false;
									bulletArray[i].visible = false;
									//place it right where the collision occurred
									//bulletArray[i].position.copy(bulletRayCollisionPoint);
									largeAsteroids[c].alive = false;
									largeAsteroids[c].visible = false;
									
									//spawn 2 new medium asteroids
									mediumAsteroids[c*2].alive = true;
									mediumAsteroids[c*2].visible = true;
									mediumAsteroids[c*2].position.copy(largeAsteroids[c].position);
									mediumAsteroids[c*2].translateOnAxis(mediumAsteroids[c*2].direction, mediumAsteroids[c*2].geometry.boundingSphere.radius);
									mediumAsteroids[c*2+1].alive = true;
									mediumAsteroids[c*2+1].visible = true;
									mediumAsteroids[c*2+1].position.copy(largeAsteroids[c].position);
									mediumAsteroids[c*2+1].translateOnAxis(mediumAsteroids[c*2+1].direction, mediumAsteroids[c*2+1].geometry.boundingSphere.radius);
									
									initExplosionPieces(largeAsteroids[c].position);
									
									/*	
									//the following is optional:
									//get the collisionNormal so we can bounce the bullet off the sphere
									collisionNormal.subVectors(largeAsteroids[i].position, bulletRayCollisionPoint);
									collisionNormal.normalize();
									// the following will send the bullet projectile on its new path
									//bulletArray[i].direction.reflect(collisionNormal);
									//bulletArray[i].alive = true;
									*/
								}

							}//end if (bulletRayCollisionPoint) {
							
						}//end if(largeAsteroids[c].alive) {
						
					}//end for(var c = 0; c < numberOfLargeAsteroids; c++) {

				}//end if (bulletArray[i].alive){
				
			}//end for (var i = 0; i < MAX_BULLETS; i++)
			
			//loop through largeAsteroids and check for collisions with other largeAsteroids
			for (var i = 0; i < numberOfLargeAsteroids; i++) {
				//only check alive asteroids
				if (largeAsteroids[i].alive && !largeAsteroids[i].hasCollided) {
					//loop through other largeAsteroids
					for (var iL = 0; iL < numberOfLargeAsteroids; iL++) {
						//if other asteroid is not alive, or if we are checking against self, 
						//then skip and continue to next loop
						if (!largeAsteroids[iL].alive || i==iL || largeAsteroids[iL].hasCollided) 
							continue;
						stepSimulation(largeAsteroids[i],largeAsteroids[iL]);
					}
				}
			}
			
			//loop through largeAsteroids and check for collisions with mediumAsteroids
			for (var i = 0; i < numberOfLargeAsteroids; i++) {
				if (largeAsteroids[i].alive && !largeAsteroids[i].hasCollided) {
					for (var iM = 0; iM < numberOfMediumAsteroids; iM++) {
						if (!mediumAsteroids[iM].alive || mediumAsteroids[iM].hasCollided) 
							continue;
						stepSimulation(largeAsteroids[i],mediumAsteroids[iM]);
					}
				}
			}
			
			//loop through largeAsteroids and check for collisions with smallAsteroids
			for (var i = 0; i < numberOfLargeAsteroids; i++) {
				if (largeAsteroids[i].alive && !largeAsteroids[i].hasCollided) {
					for (var iS = 0; iS < numberOfSmallAsteroids; iS++) {
						if (!smallAsteroids[iS].alive || smallAsteroids[iS].hasCollided) 
							continue;
						stepSimulation(largeAsteroids[i],smallAsteroids[iS]);
					}
				}
			}
			
			//loop through mediumAsteroids and check for collisions with other mediumAsteroids
			for (var i = 0; i < numberOfMediumAsteroids; i++) {
				if (mediumAsteroids[i].alive && !mediumAsteroids[i].hasCollided) {
					for (var iM = 0; iM < numberOfMediumAsteroids; iM++) {
						if (!mediumAsteroids[iM].alive || i==iM || mediumAsteroids[iM].hasCollided) 
							continue;
						stepSimulation(mediumAsteroids[i],mediumAsteroids[iM]);
					}
				}
			}
			
			//loop through mediumAsteroids and check for collisions with smallAsteroids
			for (var i = 0; i < numberOfMediumAsteroids; i++) {
				if (mediumAsteroids[i].alive && !mediumAsteroids[i].hasCollided) {
					for (var iS = 0; iS < numberOfSmallAsteroids; iS++) {
						if (!smallAsteroids[iS].alive || smallAsteroids[iS].hasCollided) 
							continue;
						stepSimulation(mediumAsteroids[i],smallAsteroids[iS]);
					}
				}
			}
			
			//loop through smallAsteroids and check for collisions with other smallAsteroids
			for (var i = 0; i < numberOfSmallAsteroids; i++) {
				if (smallAsteroids[i].alive && !smallAsteroids[i].hasCollided) {
					for (var iS = 0; iS < numberOfSmallAsteroids; iS++) {
						if (!smallAsteroids[iS].alive || i==iS || smallAsteroids[iS].hasCollided) 
							continue;
						stepSimulation(smallAsteroids[i],smallAsteroids[iS]);
					}
				}
			}
			
			//reset largeAsteroids[i].hasCollided flag back to 'false' for next animation frame
			for (var i = 0; i < numberOfLargeAsteroids; i++) {
				largeAsteroids[i].hasCollided = false;
			}
			//reset mediumAsteroids[i].hasCollided flag back to 'false' for next animation frame
			for (var i = 0; i < numberOfMediumAsteroids; i++) {
				mediumAsteroids[i].hasCollided = false;
			}
			//reset smallAsteroids[i].hasCollided flag back to 'false' for next animation frame
			for (var i = 0; i < numberOfSmallAsteroids; i++) {
				smallAsteroids[i].hasCollided = false;
			}
			
			
			//move the ship along its normalized axis vector, at the rate of shipSpeed times the framerate
			ship.translateOnAxis(normalizedShipDirection, shipSpeed * frameTime);
			//if player ship leaves the boundaries of the game arena,
			//warp the ship to opposite side of arena, like old Asteroids 'screen-wrap'
			if (ship.position.x > arenaHalfSize){
				ship.position.x = -arenaHalfSize;
				playingWarpAnimation = true;
			}
			if (ship.position.x < -arenaHalfSize){
				ship.position.x = arenaHalfSize;
				playingWarpAnimation = true;
			}
			if (ship.position.y > arenaHalfSize){
				ship.position.y = -arenaHalfSize;
				playingWarpAnimation = true;
			}
			if (ship.position.y < -arenaHalfSize){
				ship.position.y = arenaHalfSize;
				playingWarpAnimation = true;
			}
			if (ship.position.z > arenaHalfSize){
				ship.position.z = -arenaHalfSize;
				playingWarpAnimation = true;
			}
			if (ship.position.z < -arenaHalfSize){
				ship.position.z = arenaHalfSize;
				playingWarpAnimation = true;
			}
			//set camera position from ship position
			camera.position.copy(ship.position);
			
			skyBox.position.copy(camera.position);
			
			planet.position.x = camera.position.x - 900;
			planet.position.y = camera.position.y - 900;
			planet.position.z = camera.position.z - 900;
			
			if (playingWarpAnimation) {
				
				camera.fov += fovIncrementAmount * frameTime;
				camera.aspect -= aspectIncrementAmount * frameTime;
				
				if(camera.fov > 179){
					camera.fov = 179;
					fovIncrementAmount = -fovIncrementAmount;
					aspectIncrementAmount = -aspectIncrementAmount;
				}
				if(camera.fov < 65){
					camera.fov = 65;
					camera.aspect = window.innerWidth / window.innerHeight;
					fovIncrementAmount = -fovIncrementAmount;
					aspectIncrementAmount = -aspectIncrementAmount;
					playingWarpAnimation = false;
				}
				
				camera.updateProjectionMatrix();
				
			}
			
			// if explosion has occurred, update the exploding pieces
			if (isExploding) {
				
				for (var i = 0; i < numberOfExplosionPieces; i++) {
					explosionPieces[i].translateOnAxis(explosionPieces[i].direction, explosionPieces[i].speed * frameTime);
				}
				
				explosionTimer.run(frameTime);
				
				if (explosionTimer.alarmSounding) {
					for (var i = 0; i < numberOfExplosionPieces; i++) {
						explosionPieces[i].visible = false;
					}
					isExploding = false;
				}
				
			}
			
			box.rotation.y += frameTime;
			//pyramid.rotation.x += frameTime;
			//pyramid.rotation.y += frameTime;
			
			//test code for rotating sprites
			//crossHairsSprite.material.rotation += 2 * frameTime;
			
			//move and spin largeAsteroids
			for (var i = 0; i < numberOfLargeAsteroids; i++) {
				
				if(largeAsteroids[i].alive){
					//change to world coordinate system to do position translations
					largeAsteroids[i].localToWorld(largeAsteroids[i].position);
					//now move asteroid along its initial randomly-picked path
					largeAsteroids[i].translateOnAxis(largeAsteroids[i].direction, largeAsteroids[i].speed * frameTime);

					//change to local coordinate system so that asteroid rotates around its own center
					largeAsteroids[i].worldToLocal(largeAsteroids[i].position);
					//now rotate the asteroid on its initial randomly-picked axis, by the randomly-picked rotation amount
					largeAsteroids[i].rotateOnAxis(largeAsteroids[i].rotationAxis, largeAsteroids[i].rotationAmount * frameTime);

					//keep large asteroids inside the arena
					if (largeAsteroids[i].position.x > arenaHalfSize + largeAsteroidRadius)
						largeAsteroids[i].position.x = -arenaHalfSize - largeAsteroidRadius;

					if (largeAsteroids[i].position.x < -arenaHalfSize - largeAsteroidRadius)
						largeAsteroids[i].position.x = arenaHalfSize + largeAsteroidRadius;

					if (largeAsteroids[i].position.y > arenaHalfSize + largeAsteroidRadius)
						largeAsteroids[i].position.y = -arenaHalfSize - largeAsteroidRadius;

					if (largeAsteroids[i].position.y < -arenaHalfSize - largeAsteroidRadius)
						largeAsteroids[i].position.y = arenaHalfSize + largeAsteroidRadius;

					if (largeAsteroids[i].position.z > arenaHalfSize + largeAsteroidRadius)
						largeAsteroids[i].position.z = -arenaHalfSize - largeAsteroidRadius;

					if (largeAsteroids[i].position.z < -arenaHalfSize - largeAsteroidRadius)
						largeAsteroids[i].position.z = arenaHalfSize + largeAsteroidRadius;

				}//end if(largeAsteroids[i].alive)
				
			}//end for (var i = 0; i < numberOfLargeAsteroids; i++) {
			
			//move and spin mediumAsteroids
			for (var i = 0; i < numberOfMediumAsteroids; i++) {
				
				if(mediumAsteroids[i].alive){
					
					mediumAsteroids[i].localToWorld(mediumAsteroids[i].position);
					mediumAsteroids[i].translateOnAxis(mediumAsteroids[i].direction, mediumAsteroids[i].speed * frameTime);

					mediumAsteroids[i].worldToLocal(mediumAsteroids[i].position);
					mediumAsteroids[i].rotateOnAxis(mediumAsteroids[i].rotationAxis, mediumAsteroids[i].rotationAmount * frameTime);

					if (mediumAsteroids[i].position.x > arenaHalfSize + mediumAsteroidRadius)
						mediumAsteroids[i].position.x = -arenaHalfSize - mediumAsteroidRadius;

					if (mediumAsteroids[i].position.x < -arenaHalfSize - mediumAsteroidRadius)
						mediumAsteroids[i].position.x = arenaHalfSize + mediumAsteroidRadius;

					if (mediumAsteroids[i].position.y > arenaHalfSize + mediumAsteroidRadius)
						mediumAsteroids[i].position.y = -arenaHalfSize - mediumAsteroidRadius;

					if (mediumAsteroids[i].position.y < -arenaHalfSize - mediumAsteroidRadius)
						mediumAsteroids[i].position.y = arenaHalfSize + mediumAsteroidRadius;

					if (mediumAsteroids[i].position.z > arenaHalfSize + mediumAsteroidRadius)
						mediumAsteroids[i].position.z = -arenaHalfSize - mediumAsteroidRadius;

					if (mediumAsteroids[i].position.z < -arenaHalfSize - mediumAsteroidRadius)
						mediumAsteroids[i].position.z = arenaHalfSize + mediumAsteroidRadius;
					
				}//end if(mediumAsteroids[i].alive)
				
			}//end for (var i = 0; i < numberOfMediumAsteroids; i++) {
			
			//move and spin smallAsteroids
			for (var i = 0; i < numberOfSmallAsteroids; i++) {
				
				if(smallAsteroids[i].alive){
					
					smallAsteroids[i].localToWorld(smallAsteroids[i].position);
					smallAsteroids[i].translateOnAxis(smallAsteroids[i].direction, smallAsteroids[i].speed * frameTime);

					smallAsteroids[i].worldToLocal(smallAsteroids[i].position);
					smallAsteroids[i].rotateOnAxis(smallAsteroids[i].rotationAxis, smallAsteroids[i].rotationAmount * frameTime);

					if (smallAsteroids[i].position.x > arenaHalfSize + smallAsteroidRadius)
						smallAsteroids[i].position.x = -arenaHalfSize - smallAsteroidRadius;

					if (smallAsteroids[i].position.x < -arenaHalfSize - smallAsteroidRadius)
						smallAsteroids[i].position.x = arenaHalfSize + smallAsteroidRadius;

					if (smallAsteroids[i].position.y > arenaHalfSize + smallAsteroidRadius)
						smallAsteroids[i].position.y = -arenaHalfSize - smallAsteroidRadius;

					if (smallAsteroids[i].position.y < -arenaHalfSize - smallAsteroidRadius)
						smallAsteroids[i].position.y = arenaHalfSize + smallAsteroidRadius;

					if (smallAsteroids[i].position.z > arenaHalfSize + smallAsteroidRadius)
						smallAsteroids[i].position.z = -arenaHalfSize - smallAsteroidRadius;

					if (smallAsteroids[i].position.z < -arenaHalfSize - smallAsteroidRadius)
						smallAsteroids[i].position.z = arenaHalfSize + smallAsteroidRadius;
					
				}//end if(smallAsteroids[i].alive)
				
			}//end for (var i = 0; i < numberOfSmallAsteroids; i++) {
			
			//update the controls
			controls.update(frameTime);
			//render the scene with our camera
			renderer.render(scene, camera);
			
			//helpful real-time debug text, so we can monitor game variables
		/*	
			debugText1.innerHTML = "collisionPointX: " + bulletRayCollisionPoint.x.toFixed(1);
			debugText2.innerHTML = "collisionPointY: " + bulletRayCollisionPoint.y.toFixed(1);
			debugText3.innerHTML = "collisionPointZ: " + bulletRayCollisionPoint.z.toFixed(1);	
		*/
			debugText4.innerHTML = "shipSpeed: " + shipSpeed.toFixed(1);

		} //end function animate()
		
		
		function placeShip() {
			
			placingShip = true;
			
			while ( placingShip ) {
				
				placingShip = false;
				ship.position.set(Math.random() * 350 - 350, Math.random() * 350 - 350, Math.random() * 350 - 350);
				for (var i = 0; i < numberOfLargeAsteroids; i++) {
					if (largeAsteroids[i].alive && ship.position.distanceTo(largeAsteroids[i].position) < 100) 
						placingShip = true;
				}
				for (var i = 0; i < numberOfMediumAsteroids; i++) {
					if (mediumAsteroids[i].alive && ship.position.distanceTo(mediumAsteroids[i].position) < 70) 
						placingShip = true;
				}
				for (var i = 0; i < numberOfSmallAsteroids; i++) {
					if (smallAsteroids[i].alive && ship.position.distanceTo(smallAsteroids[i].position) < 50) 
						placingShip = true;
				}
				
			}
		}
		
		function shootBullet() {

			//set bullet to alive and visibility to true
			bulletArray[bulletCounter].alive = true;
			bulletArray[bulletCounter].visible = true;
			//spawn bullet at player's location
			bulletArray[bulletCounter].position.copy(ship.position);
			//reset the bullet direction vector to unit length of 1 to avoid accumulation
			bulletArray[bulletCounter].direction.set(0, 0, -1);
			//rotate the vector by our camera's rotation quaternion
			bulletArray[bulletCounter].direction.applyQuaternion(camera.quaternion);
			//now the bullet is pointing in the right direction, move it out away from the ship a little,
			//so it doesn't start right inside the ship
			bulletArray[bulletCounter].translateOnAxis(bulletArray[bulletCounter].direction, 15);
			
			//update bulletCounter for next time
			bulletCounter += 1;
			//bulletArray[] index size (bulletCounter) can't exceed MAX_BULLETS
			if(bulletCounter >= MAX_BULLETS)
				bulletCounter = 0;

		}
		
		function initExplosionPieces ( location ) {
			
			for (var i = 0; i < numberOfExplosionPieces; i++) {
				explosionPieces[i].position.copy(location);
				explosionPieces[i].visible = true;
			}
			isExploding = true;
			explosionTimer.reset();
		}
		
		//the following physics code for 'function stepSimulation(body1, body2)' is a port from the original C++ code
		//found in the 2001 book "Physics for Game Developers" by David Bourg, published by O'Reilly. I highly recommend
		//this great book which covers almost all aspects of putting physics into your games and/or projects.
		//the book's companion website is: http://shop.oreilly.com/product/9780596000066.do and the original C++ source code
		//is located at:  http://examples.oreilly.com/9780596000066/
		function stepSimulation( body1, body2 ) {
			
			fTime = frameTime;
			tryAgain = true;
			check = 0;
			combinedRadii = body1.geometry.boundingSphere.radius + body2.geometry.boundingSphere.radius;
			
			while ( tryAgain && (fTime > 0.00001) ) {
				
				tryAgain = false;
				
				asteroidCopy1.position.copy(body1.position);
				asteroidCopy2.position.copy(body2.position);
				
				asteroidCopy1.translateOnAxis(body1.direction, body1.speed * fTime);
				asteroidCopy2.translateOnAxis(body2.direction, body2.speed * fTime);
				
				distanceBetweenBodies.subVectors(asteroidCopy1.position, asteroidCopy2.position);
				separation = distanceBetweenBodies.length() - combinedRadii;
				distanceBetweenBodies.normalize();
				collisionNormal.copy(distanceBetweenBodies);

				velocity1.copy(body1.direction);
				velocity1.multiplyScalar(body1.speed);
				velocity2.copy(body2.direction);
				velocity2.multiplyScalar(body2.speed);
				relativeVelocity.subVectors(velocity1, velocity2);
				relativeDotNormal = relativeVelocity.dot(collisionNormal);
				
				if ( Math.abs(separation) <= 1 && relativeDotNormal < 0.0 ) {
					check = 1;//collision
				} else if (separation < -1) {
					check = -1;//penetrating
				} else {
					check = 0;//no collision
					//howManyTries = 0;
				}
	
				if (check == -1) { //penetrating
					
					tryAgain = true;
					fTime /= 2;
					//howManyTries += 1;
				
				} else if (check == 1) { //collision
					
					//debugText3.innerHTML = "howManyTries: " + Math.floor(howManyTries);
					//apply impulse
					combinedMass = body1.mass + body2.mass;
					impulseAmount = -0.4 * ( relativeVelocity.dot(collisionNormal) / (collisionNormal.dot(collisionNormal) * (1/combinedMass) ) );

					collisionNormal.multiplyScalar(impulseAmount);
					Vcn1.copy(collisionNormal); Vcn1.divideScalar(body1.mass);
					Vcn2.copy(collisionNormal); Vcn2.divideScalar(body2.mass);
					velocity1.add(Vcn1);
					velocity2.sub(Vcn2);
					body1.speed = velocity1.length();
					velocity1.normalize();
					body1.direction.copy(velocity1);
					body2.speed = velocity2.length();
					velocity2.normalize();
					body2.direction.copy(velocity2);
					
					body1.hasCollided = true;
					body2.hasCollided = true;
					numOfAsteroidCollisions += 1;
					debugText2.innerHTML = "numOfAsteroidCollisions: " + Math.floor(numOfAsteroidCollisions);
				
				}//end else if (check == 1) { //collision
				
			}//end while ( tryAgain && fTime > 0.01 )
				
		}//end function stepSimulation( body1, body2 )
		
		
	
	</script>
</body>

</html>
